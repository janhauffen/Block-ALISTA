# -*- coding: utf-8 -*-
"""Optimize_GenBlockCoheherence.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BpLxyELF1I-Vc9qcErYuATo70xKQ_mak
"""
import pdb

import cvxpy as cp
import numpy as np
from scipy.linalg import toeplitz, circulant
import matplotlib.pyplot as plt

def R(D, n, d):
    n_y, n_x  = D.shape
    R = np.zeros((n,n))
    for k in range(0,n):
      for l in range(k,n):
          I = np.zeros((n_x,n_x))
          I_s = np.zeros((n,n))
          I[l*d:(l+1)*d, k*d:(k+1)*d] = np.ones(d)
          I_s[l,k] = 1 
          if k==l:
            R = R+cp.norm(cp.multiply(I,D), 2)*I_s
          else:
            R = R+cp.norm(cp.multiply(I,D), 2)*I_s+cp.norm(cp.multiply(I.T,D), 2)*I_s.T
        
    return R

"""# Test for a random Matrix D"""

d = 1 # number of block length
m = 50
n = 75 # number of blocks
D = np.zeros((m*d, n*d))
for l in range(0,n):
    D[:,l*d:(l+1)*d] = np.random.random(size=(m*d, d))
    D[:,l*d:(l+1)*d], _ = np.linalg.qr(D[:,l*d:(l+1)*d])
#pdb.set_trace()
# Construct the problem.
B_cvx = cp.Variable((m*d,n*d))

I = np.kron(np.eye(n), np.ones((d, d)))
k = np.tile(np.eye(d), (1, n)).T
b = cp.multiply(B_cvx.T@D, I)
b = cp.matmul(b, k) #extracting the diagonal blocks of D^TB
constraints = [b == k]

objective = cp.Minimize(1/d*cp.max(R(B_cvx.T@D-np.eye(n*d), n, d)))

#objective = cp.Minimize(cp.max(cp.abs(A.T@x-np.eye(n))))

prob = cp.Problem(objective, constraints)

# The optimal objective value is returned by `prob.solve()`.
result = prob.solve()
# The optimal value for x is stored in `x.value`.
#print(x.value)
# The optimal Lagrange multiplier for a constraint is stored in
# `constraint.dual_value`.
#print(constraints[0].dual_value)
print(result)

"""first block of $B^TD$"""

(B_cvx.value.T@D)[0:d,0:d]

# Construct the problem.
B_up = cp.Variable((m*d,n*d))

I = np.kron(np.eye(n), np.ones((d, d)))
k = np.tile(np.eye(d), (1, n)).T
b = cp.multiply(B_up.T@D, I)
b = cp.matmul(b, k) #extracting the diagonal blocks of D^TB
constraints = [b == k]

objective = cp.Minimize(1/d*(cp.norm(B_up.T@D, 'fro')**2))

#objective = cp.Minimize(cp.max(cp.abs(A.T@x-np.eye(n))))

prob = cp.Problem(objective, constraints)

# The optimal objective value is returned by `prob.solve()`.
result = prob.solve()
# The optimal value for x is stored in `x.value`.
#print(x.value)
# The optimal Lagrange multiplier for a constraint is stored in
# `constraint.dual_value`.
#print(constraints[0].dual_value)
print(result)

